options
{
    STATIC = false;
    JAVA_UNICODE_ESCAPE = true;
    MULTI = true;
    NODE_DEFAULT_VOID = true;          // Only create Node classes for the #Tokens
}

PARSER_BEGIN(ExpressionParser)

/*
Copyright 2013 Sandia Corporation.
Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
the U.S. Government retains certain rights in this software.
Distributed under the BSD-3 license. See the file LICENSE for details.
*/

package gov.sandia.n2a.language.parse;

import gov.sandia.n2a.language.type.Scalar;
import gov.sandia.n2a.language.type.Text;

import java.io.StringReader;

public class ExpressionParser
{
    public static SimpleNode parse (String line) throws ParseException
    {
        try
        {
            ExpressionParser parser = new ExpressionParser (new StringReader (line + "\n"));
            Node startNode = parser.Start ();
            SimpleNode result = (SimpleNode) startNode.jjtGetChild (0);
            return result;
        }
        catch (TokenMgrError t)
        {
            throw new ParseException ("Lexical error");
        }
    }
}
PARSER_END(ExpressionParser)

/***************************************************************
SKIP
***************************************************************/

<DEFAULT> SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"

  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>         // Should include EOF, will add \n in input until this is fixed.
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
TOKENS
***************************************************************/

<DEFAULT> TOKEN:
{
    <FLOATING_POINT_LITERAL:
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
        | "." (["0"-"9"])+ (<EXPONENT>)?
        | (["0"-"9"])+ (<EXPONENT>)? > |
    <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+> |
    <STRING_LITERAL:
        "\""
        (     (~["\"","\\","\n","\r"])
            | ("\\" ["n","t","b","r","f","\\","'","\""])
        )*
        "\"" >
}

<DEFAULT> TOKEN:
{
    <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*(<TICKMARK>)*> |
    <#LETTER: ["A"-"Z", "a"-"z", "_", "$", "."]> |
    <#DIGIT: ["0"-"9"] > | 
    <#TICKMARK: "'" >
}

<DEFAULT> TOKEN:
{
    < ASSIGN: <NASSIGN>|<AASSIGN>|<CASSIGN> > |

    < #NASSIGN: "="  > |
    < #AASSIGN: "+=" > |
    < #CASSIGN: ":=" > |
    
    < COMMA:   ","  > |
    < SEMI:    ";"  > |
    < GT:      ">"  > |
    < LT:      "<"  > |
    < EQ:      "==" > |
    < LE:      "<=" > |
    < GE:      ">=" > |
    < NE:      "!=" > |
    < AND:     "&&" > |
    < OR:      "||" > |
    < PLUS:    "+"  > |
    < MINUS:   "-"  > |
    < MUL:     "*"  > |
    < HADAMUL: "&"  > |
    < DIV:     "/"  > |
    < MOD:     "%"  > |
    < NOT:     "!"  > |
    < POWER:   "^"  > |
    < TILDE:   "~"  > |
    < LSQ:     "["  > |
    < RSQ:     "]"  > |
    < LRND:    "("  > |
    < RRND:    ")"  >
}

/* Switches to the IN_UNITS lexical state for different parsing of the unit expressions */
<DEFAULT> TOKEN:
{
    < LBRC: "{" > : IN_UNITS
}

/* Switches back to the DEFAULT lexical state for normal parsing */
<IN_UNITS> TOKEN:
{
    < RBRC: "}" > : DEFAULT
}

/* Unit expressions are allowed to be a lot less structured, as the
   parsing will be done by JScience, not this parser. Only those characters
   that could conceivably be present in unit expressions are allowed here. */
<IN_UNITS> TOKEN:
{
    < UNITS: (["A"-"Z", "a"-"z", "_", "0"-"9", ".", "(", ")", "+", "-", "*", "/", "^"])+ >
}


/***************************************************************
GRAMMAR START
***************************************************************/

ASTStart Start() #Start : {}
{
    CommaExpression() <EOF>
    {
        return jjtThis;
    }
}

void CommaExpression() #List : {}
{
    OrExpression() (<COMMA> OrExpression())*
    {
    	jjtThis.jjtSetValue("LIST");
    }
}

void OrExpression() : {}
{
    AndExpression()
    (
        (<OR> AndExpression()
            {
                jjtThis.jjtSetValue("||");
            }
        ) #Operator(2)
    )*
}

void AndExpression() : {}
{
    EqualExpression()
    (
        (<AND> EqualExpression()
            {
                jjtThis.jjtSetValue("&&");
            }
        ) #Operator(2)
    )*
}

void EqualExpression() : {}
{
    RelationalExpression()
    (
        (<NE> RelationalExpression()
            {
                jjtThis.jjtSetValue("!=");
            }
        ) #Operator(2)
          |
        (<EQ> RelationalExpression()
            {
                jjtThis.jjtSetValue("==");
            }
        ) #Operator(2)
    )*
}

void RelationalExpression() : {}
{
    AdditiveExpression()
    (
        (<LT> AdditiveExpression()
            {
                jjtThis.jjtSetValue("<");
            }
        ) #Operator(2)
          |
        (<GT> AdditiveExpression()
            {
                jjtThis.jjtSetValue(">");
            }
        ) #Operator(2)
          |
        (<LE> AdditiveExpression()
            {
                jjtThis.jjtSetValue("<=");
            }
        ) #Operator(2)
          |
        (<GE> AdditiveExpression()
            {
                jjtThis.jjtSetValue(">=");
            }
        ) #Operator(2)
    )*
}

void AdditiveExpression() : {}
{
    MultiplicativeExpression()
    (
        (<PLUS> MultiplicativeExpression()
            {
                jjtThis.jjtSetValue("+");
            }
        ) #Operator(2)
          |
        (<MINUS> MultiplicativeExpression()
            {
                jjtThis.jjtSetValue("-");
            }
        ) #Operator(2)
    )*
}

void MultiplicativeExpression() : {}
{
    PowerExpression()
    (
        (<MUL> PowerExpression()
            {
                jjtThis.jjtSetValue("*");
            }
        ) #Operator(2)
          |
        (<HADAMUL> PowerExpression()
            {
                jjtThis.jjtSetValue("&");
            }
        ) #Operator(2)
          |
        (<DIV> PowerExpression()
            {
                jjtThis.jjtSetValue("/");
            }
        ) #Operator(2)
          |
        (<MOD> PowerExpression()
            {
                jjtThis.jjtSetValue("%");
            }
        ) #Operator(2)
    )*
}

// TODO: Make this rule right-associative. This is, a^b^c is parsed as a^(b^c).
void PowerExpression() : {}
{
    UnaryExpression()
    (
        (<POWER> UnaryExpression()
            {
                jjtThis.jjtSetValue("^");
            }
        ) #Operator(2)
    )*
}

// TODO: Make this rule recursive and right-associative.
void UnaryExpression() : {}
{
    (<MINUS> PrimaryExpression()
        {
            jjtThis.jjtSetValue("UM");
        }
    ) #Operator(1)
      |
    (<NOT> PrimaryExpression()
        {
            jjtThis.jjtSetValue("!");
        }
    ) #Operator(1)
      |
    (<TILDE> PrimaryExpression()
        {
            jjtThis.jjtSetValue("~");
        }
    ) #Operator(1)
      |
    PrimaryExpression()
}

void PrimaryExpression() : {}
{
    Constant()
      |
    Identifier()
      |
    <LRND> OrExpression() <RRND> 
      |
    MatrixExpression()
}

// TODO: Make () an operation that applies to any expression, not just variables and functions.
void MatrixExpression() #Matrix : {}
{
    <LSQ> CommaExpression() (<SEMI> CommaExpression())* <RSQ>
}

void Identifier() #Identifier : {Token t;}
{
    t = <IDENTIFIER> [<LRND> CommaExpression() <RRND>]
    {
        jjtThis.jjtSetValue(t.image);
    }
}

void Constant() #Constant : {Token t;}
{
    t = <STRING_LITERAL>
    {
        Text text = new Text (t.image.substring (1, t.image.length() - 1));
        text.removeEscapes ();
        jjtThis.jjtSetValue (text);
    }
      |
    t = <FLOATING_POINT_LITERAL>
    {
        jjtThis.jjtSetValue (new Scalar (Double.parseDouble (t.image)));
    }
}
