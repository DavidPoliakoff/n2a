/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. n2a.jj */
/*@egen*/
options
{
    OUTPUT_DIRECTORY = "../gen";
    STATIC = false;
    JAVA_UNICODE_ESCAPE = true;
                 
                   
                                         
                                                                                  
                               
}

PARSER_BEGIN(ExpressionParser)

/*
Copyright 2013 Sandia Corporation.
Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
the U.S. Government retains certain rights in this software.
Distributed under the BSD-3 license. See the file LICENSE for details.
*/

package gov.sandia.n2a.language.gen;

import java.lang.reflect.Field;
import java.io.StringReader;

import gov.sandia.n2a.language.functions.FunctionList;
import gov.sandia.n2a.language.functions.Function;

import replete.util.ReflectionUtil;

import javax.measure.unit.*;

/**
 * This parser attempts to be a relatively simple mathematical
 * expression parser.  The parser has support for these constructs:
 *  - numeric literals, integers, longs, floats, doubles, and e notation
 *  - string literals
 *  - variables (identified by an identifier)
 *  - functions (identified by an identifier, (), and any arguments)
 *  - matrices (identified by [] and its elements)
 *  - array/matrix indexing (identified by var[idx(, idx)*])
 *  - mathematical && programming operators:
 *      mathematical: + - * / % (mod) ^ unary minus, unary plus
 *      logical: && || !
 *      equality: == !=
 *      relational: < > <= >=
 *      grouping: ()
 *  - units (for physics applications)
 * 
 * An identifier is a-zA-Z0-9 and can have _, $, and . in them.  They
 * cannot start with 0-9 nor a period (.).  They cannot end in a period.
 * They can end with any number of tick marks (single quotes, ') to identify
 * derivatives.
 * 
 * Right now the units supported are all those supported by the JScience 
 * library (SI prefixes are supported by JScience as well).  More units
 * can be added if necessary.
 *
 * This parser returns the root node of an abstract syntax tree that represents
 * the expression.
 * 
 * An expression such as "x = 3y" contains a malformed identifier "3y"
 * rather than the product "3*y".
 * An matrix expression such as "[x 5 -3]" contains two elements "x" and "5-3",
 * rather than three elements. 
 *
 * Although this parser allows functions to have any name (e.g. "foobar(3, 4)"), 
 * only those functions implemented in the application would allow a parsed
 * expression to be evaluated.  Unknown functions simply provide the tree
 * node for the function with an instance of UnknownFunction, which does not
 * evaluate.
 * 
 * Assignment operators currently require that the left hand side operand be
 * either a variable or an array access.
 * 
 * The parser is generated by the JTree extension on top of JavaCC which 
 * automatically generates the AST classes for the developer.
 * 
 * Future possibilities:
 *  - list indexing elevated to full operator, trailing any expression
 *  - Ternary operator
 */

public class ExpressionParser/*@bgen(jjtree)*/implements ExpressionParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTExpressionParserState jjtree = new JJTExpressionParserState();

/*@egen*/
    public static ASTNodeBase parse (String line) throws ParseException
    {
        if (line == null)
        {
            throw new IllegalArgumentException ("Line to parse cannot be null.");
        }

        // The following classes perform some obvious transformations to the AST before returning it:
        // List[A (only one node)] --> A
        // Variable[List[A B C ...]] --> Variable[A B C ...]
        // Function[List[A B C ...]] --> Function[A B C ...]

        class CollapseList implements ASTNodeTransformer
        {
            public ASTNodeBase transform (ASTNodeBase node)
            {
                if (node.getCount () == 1)
                {
                    return node.getChild (0);
                }
                return node;
            }
        }

        class MakeListIntoChildren implements ASTNodeTransformer
        {
            public ASTNodeBase transform (ASTNodeBase node)
            {
                if (node.getCount () == 1)
                {
                    ASTNodeBase list = node.getChild (0);
                    if (list instanceof ASTListNode)
                    {
                        node.clearChildren ();
                        int count = list.getCount ();
                        for (int i = 0; i < count; i++)
                        {
                            node.setChild (list.getChild (i), i);
                        }
                    }
                }
                return node;
            }
        }

        ASTTransformationContext context = new ASTTransformationContext ();
        MakeListIntoChildren l = new MakeListIntoChildren ();
        context.add (ASTFunNode .class, l);
        context.add (ASTVarNode .class, l);
        context.add (ASTListNode.class, new CollapseList ());

        try
        {
            ExpressionParser parser = new ExpressionParser (new StringReader (line + "\n"));
            Node startNode = parser.Start ();
            ASTNodeBase result = (ASTNodeBase) startNode.jjtGetChild(0);
            result = result.transform (context);
            result.setSource (line);
            return result;
        }
        catch (ParseException p)
        {
            // This is so any possible ParseException has its message
            // properly appended with the original equation text.
            ReflectionUtil.set ("detailMessage", p, p.getMessage ().trim () + "\nSource Line: " + line);
            throw p;
        }
        catch (TokenMgrError t)
        {
            ParseException p = new ParseException (t.getMessage () + "\nSource Line: " + line);
            try
            {
                Field f = Throwable.class.getDeclaredField ("cause");
                f.setAccessible (true);
                f.set (p, t);
            }
            catch (Exception e) {}
            throw p;
        }
    }
    
    private String replaceEscape(String inputStr) {
        int len = inputStr.length();
        int p = 0;
        int i;
        String metachars = "tnrbf\\\"'";
        String chars = "\t\n\r\b\f\\\"'";

        StringBuffer output = new StringBuffer();

        while((i = inputStr.indexOf('\\', p)) != -1) {
            output.append(inputStr.substring(p, i));

            if(i + 1 == len)
                break;

            // find metacharacter
            char metac = inputStr.charAt(i + 1);

            // find the index of the metac
            int k = metachars.indexOf(metac);
            if(k == -1) {
                // didn't find the metachar, leave sequence as found.
                // This code should be unreachable if the parser
                // is functioning properly because strings containing
                // unknown escape characters should not be accepted.
                output.append('\\');
                output.append(metac);
            } else {
                // its corresponding true char
                output.append(chars.charAt(k));
            }

            // skip over both escape character & metacharacter
            p = i + 2;
        }

        // add the end of the input string to the output
        if(p < len)
            output.append(inputStr.substring(p));

        return output.toString();
    }
}
PARSER_END(ExpressionParser)

/***************************************************************
SKIP
***************************************************************/

<DEFAULT> SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"

  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>         // Should include EOF, will add \n in input until this is fixed.
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
TOKENS
***************************************************************/

<DEFAULT> TOKEN:
{
    <FLOATING_POINT_LITERAL:
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
        | "." (["0"-"9"])+ (<EXPONENT>)?
        | (["0"-"9"])+ (<EXPONENT>)? > |
    <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+> |
    <STRING_LITERAL:
        "\""
        (     (~["\"","\\","\n","\r"])
            | ("\\" ["n","t","b","r","f","\\","'","\""])
        )*
        "\"" >
}

<DEFAULT> TOKEN:
{
    <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*(<TICKMARK>)*> |
    <#LETTER: ["A"-"Z", "a"-"z", "_", "$", "."]> |
    <#DIGIT: ["0"-"9"] > | 
    <#TICKMARK: "'" >
}

<DEFAULT> TOKEN:
{
    < ASSIGN: <NASSIGN>|<AASSIGN>|<CASSIGN> > |

    < #NASSIGN: "="  > |
    < #AASSIGN: "+=" > |
    < #CASSIGN: ":=" > |
    
    < COMMA: ","  > |
    < SEMI:  ";"  > |
    < GT:    ">"  > |
    < LT:    "<"  > |
    < EQ:    "==" > |
    < LE:    "<=" > |
    < GE:    ">=" > |
    < NE:    "!=" > |
    < AND:   "&&" > |
    < OR:    "||" > |
    < PLUS:  "+"  > |
    < MINUS: "-"  > |
    < MUL:   "*"  > |
    < DIV:   "/"  > |
    < MOD:   "%"  > |
    < NOT:   "!"  > |
    < POWER: "^"  > |
    < LSQ:   "["  > |
    < RSQ:   "]"  > |
    < LRND:  "("  > |
    < RRND:  ")"  >
}

/* Switches to the IN_UNITS lexical state for different parsing of the unit expressions */
<DEFAULT> TOKEN:
{
    < LBRC: "{" > : IN_UNITS
}

/* Switches back to the DEFAULT lexical state for normal parsing */
<IN_UNITS> TOKEN:
{
    < RBRC: "}" > : DEFAULT
}

/* Unit expressions are allowed to be a lot less structured, as the
   parsing will be done by JScience, not this parser. Only those characters
   that could conceivably be present in unit expressions are allowed here. */
<IN_UNITS> TOKEN:
{
    < UNITS: (["A"-"Z", "a"-"z", "_", "0"-"9", ".", "(", ")", "+", "-", "*", "/", "^"])+ >
}


/***************************************************************
GRAMMAR START
***************************************************************/

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    AssignExpression() <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AssignExpression() : {
    Token t;
}
{    
    LOOKAHEAD(Variable() <ASSIGN>) Variable() t = <ASSIGN> CommaExpression()/*@bgen(jjtree) #OpNode( 2) */
    {
      ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
    }
/*@egen*/
    {
        jjtn001.jjtSetValue(FunctionList.get(t.image));
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/           
      |
    CommaExpression()
}

void CommaExpression()           : {/*@bgen(jjtree) ListNode */
  ASTListNode jjtn000 = new ASTListNode(JJTLISTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListNode */
    try {
/*@egen*/
    OrExpression() (<COMMA> OrExpression())*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    	jjtn000.jjtSetValue("LIST");
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void OrExpression() : {}
{
    AndExpression()
    (/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<OR> AndExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
                jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_OR));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/           
    )*
}

void AndExpression() : {}
{
    EqualExpression()
    (/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<AND> EqualExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
                jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_AND));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/           
    )*
}

void EqualExpression() : {}
{
    RelationalExpression()
    (/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<NE> RelationalExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
                jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_NE));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/           
          |/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn002 = new ASTOpNode(JJTOPNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<EQ> RelationalExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            {
                jjtn002.jjtSetValue(FunctionList.get(FunctionList.OP_EQ));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/           
    )*
}

void RelationalExpression() : {}
{
    AdditiveExpression()
    (/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<LT> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
                jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_LT));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/           
          |/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn002 = new ASTOpNode(JJTOPNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<GT> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            {
                jjtn002.jjtSetValue(FunctionList.get(FunctionList.OP_GT));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/           
          |/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn003 = new ASTOpNode(JJTOPNODE);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
        (<LE> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn003,  2);
              jjtc003 = false;
            }
/*@egen*/
            {
                jjtn003.jjtSetValue(FunctionList.get(FunctionList.OP_LE));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  2);
          }
        }
/*@egen*/           
          |/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn004 = new ASTOpNode(JJTOPNODE);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*/
        (<GE> AdditiveExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn004,  2);
              jjtc004 = false;
            }
/*@egen*/
            {
                jjtn004.jjtSetValue(FunctionList.get(FunctionList.OP_GE));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte004) {
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte004 instanceof RuntimeException) {
            throw (RuntimeException)jjte004;
          }
          if (jjte004 instanceof ParseException) {
            throw (ParseException)jjte004;
          }
          throw (Error)jjte004;
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004,  2);
          }
        }
/*@egen*/           
    )*
}

void AdditiveExpression() : {}
{
    MultiplicativeExpression()
    (/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<PLUS> MultiplicativeExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
                jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_ADD));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/           
          |/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn002 = new ASTOpNode(JJTOPNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<MINUS> MultiplicativeExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            {
                jjtn002.jjtSetValue(FunctionList.get(FunctionList.OP_SUBTRACT));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/           
    )*
}

void MultiplicativeExpression() : {}
{
    UnitExpression()
    (/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<MUL> UnitExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
                jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_MULTIPLY));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/           
          |/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn002 = new ASTOpNode(JJTOPNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<DIV> UnitExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtc002 = false;
            }
/*@egen*/
            {
                jjtn002.jjtSetValue(FunctionList.get(FunctionList.OP_DIVIDE));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/           
          |/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn003 = new ASTOpNode(JJTOPNODE);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
        (<MOD> UnitExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn003,  2);
              jjtc003 = false;
            }
/*@egen*/
            {
                jjtn003.jjtSetValue(FunctionList.get(FunctionList.OP_MOD));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  2);
          }
        }
/*@egen*/           
    )*
}

/* Unary Expression With Units:
   Units act as a post-fix operator with precedence
   higher than +, -, *, /, and %, but lower than 
   ^, unary minus, unary plus, and element []. */
   
void UnitExpression() : {
    Token t;
}
{
    LOOKAHEAD(UnaryExpression() <LBRC>)/*@bgen(jjtree) UnitNode */
    {
      ASTUnitNode jjtn001 = new ASTUnitNode(JJTUNITNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (UnaryExpression() <LBRC> t = <UNITS> <RBRC>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
        {
            jjtn001.jjtSetValue(Unit.valueOf(t.image));
        }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/          
      | 
    UnaryExpression()
}

void UnaryExpression() : {}
{/*@bgen(jjtree) #OpNode( 1) */
    {
      ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<PLUS> PowerExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  1);
          jjtc001 = false;
        }
/*@egen*/
        {
            jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_UPLUS));
        }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
      }
    }
/*@egen*/           
      |/*@bgen(jjtree) #OpNode( 1) */
    {
      ASTOpNode jjtn002 = new ASTOpNode(JJTOPNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    (<MINUS> PowerExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002,  1);
          jjtc002 = false;
        }
/*@egen*/
        {
            jjtn002.jjtSetValue(FunctionList.get(FunctionList.OP_UMINUS));
        }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  1);
      }
    }
/*@egen*/           
      |/*@bgen(jjtree) #OpNode( 1) */
    {
      ASTOpNode jjtn003 = new ASTOpNode(JJTOPNODE);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/
    (<NOT> PowerExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003,  1);
          jjtc003 = false;
        }
/*@egen*/
        {
            jjtn003.jjtSetValue(FunctionList.get(FunctionList.OP_NOT));
        }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte003) {
      if (jjtc003) {
        jjtree.clearNodeScope(jjtn003);
        jjtc003 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte003 instanceof RuntimeException) {
        throw (RuntimeException)jjte003;
      }
      if (jjte003 instanceof ParseException) {
        throw (ParseException)jjte003;
      }
      throw (Error)jjte003;
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  1);
      }
    }
/*@egen*/           
      |
    PowerExpression()
}

// TODO: Make this rule recursive and right-associative
// In other words: a^b^c is parsed as a^(b^c)
void PowerExpression() : {}
{
    PrimaryExpression()
    [/*@bgen(jjtree) #OpNode( 2) */
        {
          ASTOpNode jjtn001 = new ASTOpNode(JJTOPNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<POWER> PrimaryExpression()/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtc001 = false;
            }
/*@egen*/
            {
                jjtn001.jjtSetValue(FunctionList.get(FunctionList.OP_POWER));
            }
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/           
    ]
}

void PrimaryExpression() : {}
{
    Constant()
      |
    LOOKAHEAD({getToken(1).kind == IDENTIFIER && getToken(2).kind == LRND}) Function()
      |
    Variable()
      |
    <LRND> OrExpression() <RRND> 
      |
    MatrixExpression()
}

void MatrixExpression()             : {/*@bgen(jjtree) MatrixNode */
    ASTMatrixNode jjtn000 = new ASTMatrixNode(JJTMATRIXNODE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    jjtn000.jjtSetValue("MATRIX");
}
{/*@bgen(jjtree) MatrixNode */
    try {
/*@egen*/
    <LSQ> CommaExpression() (<SEMI> CommaExpression())* <RSQ>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Variable()          : {/*@bgen(jjtree) VarNode */
    ASTVarNode jjtn000 = new ASTVarNode(JJTVARNODE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) VarNode */
    try {
/*@egen*/
    t = <IDENTIFIER> [<LSQ> CommaExpression() <RSQ>]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.jjtSetValue(t.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Function()          : {/*@bgen(jjtree) FunNode */
    ASTFunNode jjtn000 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) FunNode */
    try {
/*@egen*/
    t = <IDENTIFIER> <LRND> [CommaExpression()] <RRND>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.jjtSetValue(FunctionList.getOrUnknown(t.image));
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Constant()           : {/*@bgen(jjtree) Constant */
    ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Constant */
    try {
/*@egen*/
    t = <STRING_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        String temp = t.image.substring(1, t.image.length() - 1);
        temp = replaceEscape(temp);
        jjtn000.jjtSetValue(temp);
    }
      |
    t = <FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.jjtSetValue(Double.parseDouble(t.image));
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
